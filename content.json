{"meta":{"title":"人生的印记","subtitle":"","description":"","author":"William Yang","url":"https://www.yangweixing.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-06-04T12:19:27.837Z","updated":"2022-06-04T12:19:27.837Z","comments":false,"path":"/404.html","permalink":"https://www.yangweixing.top/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-06-04T12:19:27.842Z","updated":"2022-06-04T12:19:27.842Z","comments":false,"path":"about/index.html","permalink":"https://www.yangweixing.top/about/index.html","excerpt":"","text":"Hi there, I’m William Yang! 👋 Hi, I’m William Yang, a passionate self-taught frontEnd developer from China. 🔭 I’m currently working on my personal project 🌱 I’m currently learning Java &amp; Python 💬 Ask me about anything here ⚡ Fun fact: I :heart: :dog:s My Tech Stack Frontend Database"},{"title":"书单","date":"2022-06-04T12:19:27.842Z","updated":"2022-06-04T12:19:27.842Z","comments":false,"path":"books/index.html","permalink":"https://www.yangweixing.top/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-06-04T12:19:27.842Z","updated":"2022-06-04T12:19:27.842Z","comments":false,"path":"categories/index.html","permalink":"https://www.yangweixing.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-06-04T12:19:27.843Z","updated":"2022-06-04T12:19:27.843Z","comments":true,"path":"links/index.html","permalink":"https://www.yangweixing.top/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-06-04T12:19:27.843Z","updated":"2022-06-04T12:19:27.843Z","comments":false,"path":"repository/index.html","permalink":"https://www.yangweixing.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-04T12:19:27.843Z","updated":"2022-06-04T12:19:27.843Z","comments":false,"path":"tags/index.html","permalink":"https://www.yangweixing.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA 开发脚手架汇编","slug":"JAVA-开发脚手架汇编","date":"2022-06-04T13:27:01.000Z","updated":"2022-06-04T13:30:34.322Z","comments":true,"path":"2022/06/04/JAVA-开发脚手架汇编/","link":"","permalink":"https://www.yangweixing.top/2022/06/04/JAVA-%E5%BC%80%E5%8F%91%E8%84%9A%E6%89%8B%E6%9E%B6%E6%B1%87%E7%BC%96/","excerpt":"","text":"RuoYi","categories":[],"tags":[{"name":"JAVA 脚手架","slug":"JAVA-脚手架","permalink":"https://www.yangweixing.top/tags/JAVA-%E8%84%9A%E6%89%8B%E6%9E%B6/"}]},{"title":"在Java中如何正确写一个单例模式？","slug":"在Java中如何正确写一个单例模式？","date":"2020-01-02T11:47:00.000Z","updated":"2022-06-04T12:19:27.841Z","comments":true,"path":"2020/01/02/在Java中如何正确写一个单例模式？/","link":"","permalink":"https://www.yangweixing.top/2020/01/02/%E5%9C%A8Java%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%86%99%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F/","excerpt":"单例模式定义： 一个类只有一个实例，提供全局的唯一入口。比如分身术，但是每一个分身都对应同一个真身。","text":"单例模式定义： 一个类只有一个实例，提供全局的唯一入口。比如分身术，但是每一个分身都对应同一个真身。 单例模式优点： 写法简单 线程安全 防止破坏单例 为什么需要单例模式 理由一：节省内存、节省计算 例如：下面类初始化是需要查询数据库，并对查到的数据做大量的计算，所以在第一次构造的时候，花了很多时间来初始化这个对象； 但是假设我们数据库里的数据是不变的，并且把这个对象保存在了内存中，那么以后就可以用同一个实例了。 如果每次都重新生成新的实例，实在是没有必要。 1234567public class ExpensiveResource &#123; public ExpensiveResource()&#123; field1 = // 查询数据库 field2 = // 然后对查询的数据库做大量计算 field3 = // 加密、压缩等耗时操作 &#125;&#125; 理由二：保证结果的正确 例如：一个全局计数器，用来统计人数，那么有多个实例的话反而会造成混乱。 理由三：方便管理 例如：很多工具类，我们只需要一个实例，那么我们通过一个统一的入口，比如通过getInstance 方法，获取到单例，很方便。 单例模式适用场景 无状态工具类 日志工具类 只是用于记录日志信息，不需要在操作类实例对象上存储任何状态 字符串工具 全局信息类 全局计数 环境变量 单例模式写法 饿汉式 123456789public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 类装载的时候就完成了实例化，避免了线程同步的问题；==缺点在于类装载的时候就完成了实例化，没有达到懒加载的效果==；如果一直未使用该实例，就造成了内存浪费。 1234567891011121314静态代码块式写法：public class Singleton &#123; private static Singleton singleton; static &#123; singleton = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 懒汉式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051线程不安全式写法：public class Singleton &#123; private static Singleton singleton; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(singleton == null)&#123; //多线程进入会产生多实例 singleton = new Singleton(); &#125; return singleton; &#125;&#125;public class Singleton &#123; private static Singleton singleton; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(singleton == null)&#123; //多线程进入会产生多实例 synchronized (Singleton.class)&#123; singleton = new Singleton(); &#125; &#125; return singleton; &#125;&#125;&gt; 调用时进行实例化，起到懒加载效果，只能在单线程下使用，避免多线程环境下使用该写法 线程安全式写法：public class Singleton &#123; private static Singleton singleton; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125;&gt; 效率太低``` - 双重检查式 public class Singleton { private static volatile Singleton singleton; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(singleton == null)&#123; synchronized (Singleton.class)&#123; if(singleton == null)&#123; //多线程进入会产生多实例 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; } 两个if判断，第二次if判断会跳过if代码块，直接return 实例化对象；优点不仅线程安全，而且延迟加载，效率更高。缺点不能防止被反序列化，生成多个实例。 12345678910111213 - 扩展思考1：为什么要double-check? 去掉第二次的check行不行呢？ 思考：两个线程同时调用getInstance方法，并且由于singleton是空的，所以两个线程都可以通过第一重的if判断，然后由于锁机制的存在，会有一个线程先进入同步语句，并进入第二重的if判断，而另一个线程就会在外面等待，不过当第一个线程执行完 new Singleton() 语句后，就会退出 synchronized 保护的区域，如果没有第二重singleton == null的话，那么第二个线程也会创建一个实例，这就破坏了单例；如果第一check去掉，那么所有线程都会串行执行，效率低下，所以两个check都需要保留的。 - 扩展思考2：为什么要加volatile关键字？ 思考：主要在于singleton = new Singleton() 不是原子操作。防止了JVM中重排序的发生，避免了1-&gt;3-&gt;2 顺序执行过程中拿到未完成初始化的对象。 在JVM中代码执行步骤： 1）给singleton分配初始空间； 2）调用Singleton的构造函数等来初始化singleton； 3）将singleton对象指向分配的内存空间（执行完这步singleton就不是 null 了）。 由于JVM中存在==重排序现象==，执行熟悉存在 1-&gt;3-&gt;2 或者 1-&gt;2-&gt;3- 静态内部类式 public class Singleton { private Singleton()&#123;&#125; private static class SingletonInstance&#123; private static final Singleton singleton = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonInstance.singleton; &#125; } 饿汉式机制类似，采用类装载机制，来保证我们初始化实例时只有一个线程，所以JVM保证了线程的安全性；不会在类装载时实例化，而是在需要调用时实例化。优点不仅线程安全，而且延迟加载，效率更高。缺点不能防止被反序列化，生成多个实例。 12- 枚举式（最佳方式） public class EnumSingleton { INSTANCE; public EnumSingleton getInstance()&#123; return INSTANCE; &#125; } 1.写法简单，代码短小精悍，代码更简洁更优雅； 2.线程安全有保证，枚举中的各个枚举项都是通过static代码来定义和初始化的，他们会在类被加载时完成初始化，而Java类的加载由JVM保证线程安全，所以创建一个Enum 类型的枚举是线程安全的。 3.防止单例破坏，java专门对枚举序列化做了规定，在序列化是仅仅是将枚举对象的name属性输出到结果中，在反序列化时，就是通过java.lang.Enum的valueOf来根据名字查找对象，而不是新建一个新的对象，所以防止了反序列化。 ## 如何选择： &gt; Joshua Bloch 在《Effective Java》书中明确表达过一个观点：使用枚举实现单例的方法，虽然还没有被广泛采用，但是单元素的枚举类型已经成为了实现 Singleton 的最佳方法。 ## ChangeLog - 2019.03.10 19:36 初稿 - 2020.01.02 19:47 添加枚举写法","categories":[],"tags":[{"name":"设计模式 单例模式 JAVA","slug":"设计模式-单例模式-JAVA","permalink":"https://www.yangweixing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-JAVA/"}]},{"title":"微服务 之 技术栈","slug":"微服务 之 技术栈","date":"2019-12-09T13:00:00.000Z","updated":"2022-06-04T12:19:27.841Z","comments":true,"path":"2019/12/09/微服务 之 技术栈/","link":"","permalink":"https://www.yangweixing.top/2019/12/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%20%E4%B9%8B%20%E6%8A%80%E6%9C%AF%E6%A0%88/","excerpt":"1.微服务开发 作用: 快速构建开发服务.","text":"1.微服务开发 作用: 快速构建开发服务. Spring： 官网 SpringMvc SpringBoot 官网 Spring 是目前 JavaWeb 开发人员必不可少的一个框架, SpringBoot 简化了 Spring 开发的配置目前也是业内主流开发框架. 2.微服务注册发现 作用: 发现服务,注册服务,集中管理服务. Zookeeper ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. zookeeper是一个集中的服务,用于维护配置信息、命名、提供分布式同步和提供组服务. GitHub Eureka Eureka Server : 提供服务注册服务,各个节点启动后,会在Eureka Server中进行注册. Eureka Client : 简化与Eureka Server的交互操作. Spring Cloud Netflix : GitHub，文档. Nacos Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。 官网 GitHub Zookeeper保证CP , Eureka 保证AP。 APC定理，C-数据一致性;A-服务可用性;P-服务对网络分区故障的容错性,这三个特性在任何分布式系统中不能同时满足,最多同时满足两个. 3.微服务配置管理 作用:统一管理一个或多个服务的配置信息,集中管理. Disconf Distributed Configuration Management Platform(分布式配置管理平台) ,它是专注于各种分布式系统配置管理 的通用组件/通用平台, 提供统一的配置管理服务,是一套完整的基于zookeeper的分布式配置统一解决方案. GitHub Spring Cloud Config GitHub Apollo Apollo（阿波罗）是携程框架部门研发的分布式配置中心,能够集中化管理应用不同环境、不同集群的配置,配置修改后能够实时推送到应用端,并且具备规范的权限、流程治理等特性,适用于微服务配置管理场景. GitHub Nacos Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。 官网 GitHub 4.权限认证 作用:根据系统设置的安全规则或者安全策略,用户可以访问而且只能访问自己被授权的资源,不多不少. Spring Security Springsecurity 是一个强大的、高度可定制的身份验证和访问控制框架。 它是确保基于 spring 的应用程序安全的事实标准。主要致力于为 Java 应用程序提供身份验证和授权。 官网 Apache Shiro Apache Shiro是一个强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。 有了Shiro易于理解的API，你可以快速而轻松地保护任何应用程序——从最小的移动应用程序到最大的 web 和企业应用程序. 官网 5.微服务通信协议 Rest 通过HTTP/HTTPS发送Rest请求进行数据交互 RPC（Remote Procedure Call） 一种通过网络从远程计算机程序上请求服务,而不需要了解底层网络技术的协议.RPC不依赖于具体的网络传输协议,tcp、udp等都可以. gRPC A high-performance, open-source universal RPC framework 所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制,使得应用程序之间可以进行通信,而且也遵从server/client模型.使用的时候客户端调用server端提供的接口就像是调用本地的函数一样. 官网 RMI（Remote Method Invocation） 纯Java调用 6.服务接口调用 作用: 多个服务之间的通讯 Feign(HTTP) Spring Cloud Netflix 的微服务都是以 HTTP 接口的形式暴露的,所以可以用 Apache 的 HttpClient 或 Spring 的 RestTemplate 去调用,而 Feign 是一个使用起来更加方便的 HTTP 客戶端,使用起来就像是调用自身工程的方法,而感觉不到是调用远程方法. GitHub 7.服务熔断 作用: 当请求到达一定阈值时不让请求继续. Hystrix Hystrix 是一个延迟和容错库，旨在隔离访问远程系统、服务和第三方库的点，阻止级联故障，并使复杂的分布式系统中不可避免的故障恢复能力。 GitHub Sentinel Sentinel 以“流”为切入点，在流量控制、断路和系统自适应保护等多个领域开展工作，保证微服务的可靠性。 GitHub 8.服务负载均衡 作用:降低服务压力,增加吞吐量 Ribbon Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具,它基于Netflix Ribbon实现. GitHub Nginx Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器,同时也提供了IMAP/POP3/SMTP服务 GitHub Nginx 与 Ribbon区别: Nginx 属于服务端负载均衡,Ribbon属于客户端负载均衡. Nginx作用与Tomcat,Ribbon作用与各个服务之间的调用(RPC). 9.消息队列 作用: 解耦业务,异步化处理数据. Kafka 官网 RabbitMQ 官网 RocketMQ 官网 ActiveMQ 官网 10.日志采集（ELK） 作用:收集各服务日志提供日志分析、用户画像等. Elasticsearch GitHub Logstash GitHub Kibana GitHub 11.微服务网关（API-Gateway） 作用:外部请求通过API网关进行拦截处理,再转发到真正的服务. Zuul Zuul 是一个网关服务，它提供动态路由、监视、弹性、安全性等等。 GitHub Spring Cloud Gateway Spring Cloud Gateway 旨在提供一种简单而有效的方法来路由到 api，并为它们提供交叉关注点，如安全性、监视 / 度量和弹性。 官网 12.服务监控 作用:以可视化或非可视化的形式展示出各个服务的运行情况(CPU、内存、访问量等). Zabbix GitHub Nagios 官网 Metrics 官网 13.服务链路追踪 作用:明确服务之间的调用关系. Zipkin ZipKin 是一个开放源代码的分布式跟踪系统，由 Twitter 公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。 GitHub Brave GitHub Pinpoint Pinpoint 是一个用 Java / PHP 编写的大规模分布式系统的 APM (应用程序性能管理)工具。 受到 Dapper 的启发，Pinpoint 提供了一个解决方案，通过跟踪跨分布式应用程序的事务，帮助分析系统的整体结构以及其中的组件如何相互连接。 GitHub Spring Cloud Sleuth Spring Cloud Sleuth 为 Spring Cloud 实现了一个分布式跟踪解决方案，大量借鉴了 Dapper、 Zipkin 和 HTrace。 对于大多数用户来说，Sleuth 应该是不可见的，并且您与外部系统的所有交互都应该自动检测。 您可以简单地在日志中捕获数据，或者将数据发送到远程收集器服务。 官网 opentracing 官网 14.数据存储 作用: 存储数据 关系型数据库 MySql 官网 Oracle 官网 MsSql 官网 PostgreSql 官网 非关系型数据库 Mongodb 官网 Elasticsearch GitHub 15.缓存 作用: 存储数据. redis 官网 16.分库分表 作用: 数据库分库分表方案. shardingsphere 官网 Mycat 官网 服务部署 作用: 将项目快速部署、上线、持续集成. Docker 官网 Jenkins Jenkins是一款开源 CI&amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。Jenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序。 官网 Kubernetes(K8s) Kubernetes 是一个用于自动部署、扩展和管理集装箱化应用程序的开放源码系统. 官网 Mesos 一个分布式系统内核，Mesos 使用与 Linux 内核相同的原则构建，只是抽象层次不同。 Mesoskernel 可以在每台机器上运行，并为应用程序(如 Hadoop、 Spark、 Kafka、 Elasticsearch)提供 API，用于跨整个数据中心和云环境的资源管理和调度。 官网 GitLab ChangeLog 2019-12-09 21:00 初稿","categories":[],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://www.yangweixing.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"微服务 之 概念","slug":"微服务 之 概念","date":"2019-11-27T14:36:00.000Z","updated":"2022-06-04T12:19:27.841Z","comments":true,"path":"2019/11/27/微服务 之 概念/","link":"","permalink":"https://www.yangweixing.top/2019/11/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%20%E4%B9%8B%20%E6%A6%82%E5%BF%B5/","excerpt":"微服务起源 微服务是由 Peter Rodgers 博士于 2005 年度云计算博览会提出的微 Web 服务 (Micro-Web-Service) 开始，Juval Löwy 则是与他有类似的前导想法，将类别变成细粒服务 (granular services)，以作为 Microsoft 下一阶段的软件架构，其核心想法是让服务是由类似 Unix 管道的访问方式使用，而且复杂的服务背后是使用简单 URI 来开放接口，任何服务，任何细粒都能被开放 (exposed)。这个设计在 HP 的实验室被实现，具有改变复杂软件系统的强大力量。","text":"微服务起源 微服务是由 Peter Rodgers 博士于 2005 年度云计算博览会提出的微 Web 服务 (Micro-Web-Service) 开始，Juval Löwy 则是与他有类似的前导想法，将类别变成细粒服务 (granular services)，以作为 Microsoft 下一阶段的软件架构，其核心想法是让服务是由类似 Unix 管道的访问方式使用，而且复杂的服务背后是使用简单 URI 来开放接口，任何服务，任何细粒都能被开放 (exposed)。这个设计在 HP 的实验室被实现，具有改变复杂软件系统的强大力量。 2014年，Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现[1]。 什么是微服务？ The term “Microservice Architecture” has sprung up over the last few years to describe a particular way of designing software applications as suites of independently deployable services. While there is no precise definition of this architectural style, there are certain common characteristics around organization around business capability, automated deployment, intelligence in the endpoints, and decentralized control of languages and data. “微服务体系结构”这个术语在过去几年中迅速出现，用来描述一种特殊的方法，将软件应用程序设计为可独立部署的服务套件。 虽然这种架构风格没有精确的定义，但是围绕着业务能力、自动部署、端点智能以及语言和数据的分散控制，围绕着组织有一些共同的特征。 ​ – Martin Fowler Microservice 微服务 (Microservices) 是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent/Language agnostic) 的 API 集相互通信。 ​ – 维基百科（中文） Microservices are a software development technique —a variant of the service-oriented architecture (SOA) structural style— that arranges an application as a collection of loosely coupled services.[1] In a microservices architecture, services are fine-grained and the protocols are lightweight. 微服务是一种软件开发技术---- 是面向服务的体系结构结构风格的变体---- 将应用程序排列成松散耦合服务的集合。 在微服务体系结构中，服务是细粒度的，协议是轻量级的。 ​ – 维基百科 简而言之，微服务体系结构风格[1]是一种将单个应用程序开发成一套小型服务的方法，每个应用程序都在自己的进程中运行，并与轻量级机制(通常是 HTTP 资源 API)通信。 这些服务是围绕业务能力构建的，可以通过完全自动化的部署机制独立部署。 这些服务只有最低限度的集中管理，可以用不同的编程语言编写，并使用不同的数据存储技术。 微服务体系结构的特点 Characteristics of a Microservice Architecture 通过服务实现组件化 Componentization via Services 围绕业务能力组织 Organized around Business Capabilities 产品而非项目 Products not Projects 智能端点和哑管道 Smart endpoints and dumb pipes 分权治理 Decentralized Governance 分散式数据管理 Decentralized Data Management 基础设施自动化 Infrastructure Automation 为失败而设计 Design for failure 进化设计 Evolutionary Design 微服务的优点 第一，它解决了复杂问题。它把可能会变得庞大的单体应用程序分解成一套服务。虽然功能数量不变，但是应用程序已经被分解成可管理的块或者服务。每个服务都有一个明确定义边界的方式，如远程过程调用（RPC）驱动或消息驱动 API。微服务架构模式强制一定程度的模块化，实际上，使用单体代码来实现是极其困难的。因此，使用微服务架构模式，个体服务能被更快地开发，并更容易理解与维护。 第二，这种架构使得每个服务都可以由一个团队独立专注开发。开发者可以自由选择任何符合服务 API 契约的技术。当然，更多的组织是希望通过技术选型限制来避免完全混乱的状态。然而，这种自由意味着开发人员不再有可能在这种自由的新项目开始时使用过时的技术。当编写一个新服务时，他们可以选择当前的技术。此外，由于服务较小，使用当前技术重写旧服务将变得更加可行。 第三，微服务架构模式可以实现每个微服务独立部署。开发人员根本不需要去协调部署本地变更到服务。这些变更一经测试即可立即部署。比如，UI 团队可以执行 A|B 测试，并快速迭代 UI 变更。微服务架构模式使得持续部署成为可能。 最后，微服务架构模式使得每个服务能够独立扩展。您可以仅部署满足每个服务的容量和可用性约束的实例数目。此外，您可以使用与服务资源要求最匹配的硬件。例如，您可以在 ECS Compute Optimized 实例上部署一个 CPU 密集型图像处理服务，并且在 ECS Memory-optimized 实例上部署一个内存数据库服务。 微服务的缺点 第一，微服务是一个分布式系统，其使得整体变得复杂。开发者需要选择和实现基于消息或者 RPC 的进程间通信机制。此外，由于目标请求可能很慢或者不可用，他们必须要编写代码来处理局部故障。虽然这些并不是很复杂、高深，但模块间通过语言级方法/过程调用相互调用，这比单体应用要复杂得多。 第二，分区数据库架构。在基于微服务的应用程序中，您需要更新不同服务所用的数据库。通常不会选择分布式事务，不仅仅是因为 CAP 定理。他们根本不支持如今高度可扩展的 NoSQL 数据库和消息代理。您最后不得不使用基于最终一致性的方法，这对于开发人员来说更具挑战性。 第三，微服务测试应用程序也很复杂。对于微服务来说需要启动该服务及其所依赖的所有服务，或者至少为这些服务配置存根。 第四，实现了跨越多服务变更。例如，我们假设您正在实现一个变更服务 A、服务 B 和 服务 C 的需求，其中 A 依赖于 B，且 B 依赖于 C。在单体应用程序中，您可以简单地修改相应的模块、整合变更并一次性部署他们。相反，在微服务中您需要仔细规划和协调出现的变更至每个服务。例如，您需要更新服务 C，然后更新服务 B，最后更新服务 A。幸运的是，大多数变更只会影响一个服务，需要协调的多服务变更相对较少。 第五，基于微服务应用程序的部署也是相当复杂。微服务应用程序通常由大量的服务组成。要成功部署微服务应用程序，需要求开发人员能高度控制部署方式和高度自动化。 小结 微服务是将单一的应用程序拆分成多个微小的服务，各个小服务之间松耦合、高内聚，每个小服务可以单独进行开发，不依赖于具体的编程语言，也可以使用不同的数据存储技术，各个服务可以独立部署，拥有各自的进程，相互之间通过轻量化的机制进行通信（如基于http的API接口），所有的服务共同实现具体的业务功能。 微服务架构是一种思想，而真正开发时是采用分布式系统开发。 微服务的目标在于充分分解应用程序以方便应用敏捷开发和部署。 微服务的实现思路是将应用程序分解成一套较小的互联服务。 微服务通常要实现三大指标： 高可用 高性能 高并发 微服务通常面临的问题： 客户端如何访问 API Gateway 、 WebUI 服务与服务之间如何通信（对内RPC，对外RESTFUL） 同步： HTTP：跨防火墙 RPC：传输效率高 异步 消息队列 服务如何治理 注册中心 监控中心 服务挂了怎么办 重试机制 限流 熔断机制 负载均衡 降级 本地缓存 构建复杂的微服务应用程序本质上是困难的。单体架构模式只适用于简单、轻量级的应用程序，如果您使用它来构建复杂应用，您最终会陷入痛苦的境地。微服务架构模式是复杂、持续发展应用的一个更好的选择。尽管它存在着缺点和实现挑战。 参考书籍 《Microservices Patterns》 文献参考 Microservices：https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa Martin Fowler：https://martinfowler.com/ James Lewis：https://bovon.org/ 维基百科（中文）：https://zh.wikipedia.org/wiki/微服務 维基百科：https://en.wikipedia.org/wiki/Microservices ChangeLog 2019-11-27 22:26 初稿","categories":[],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://www.yangweixing.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"gulp-babel 取消严格模式(\"use strict\")","slug":"gulp-babel取消严格模式use strict","date":"2019-07-23T01:38:00.000Z","updated":"2022-06-04T12:19:27.840Z","comments":true,"path":"2019/07/23/gulp-babel取消严格模式use strict/","link":"","permalink":"https://www.yangweixing.top/2019/07/23/gulp-babel%E5%8F%96%E6%B6%88%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8Fuse%20strict/","excerpt":"插件地址 ➡️ https://github.com/genify/babel-plugin-transform-remove-strict-mode 1、安装 1npm install babel-plugin-transform-remove-strict-mode","text":"插件地址 ➡️ https://github.com/genify/babel-plugin-transform-remove-strict-mode 1、安装 1npm install babel-plugin-transform-remove-strict-mode 2、使用 添加内容到.babelrc文件 123&#123; &quot;plugins&quot;: [&quot;transform-remove-strict-mode&quot;]&#125; 重新执行打包命令即可","categories":[],"tags":[{"name":"日记本","slug":"日记本","permalink":"https://www.yangweixing.top/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"Git分支的创建、删除、切换","slug":"Git分支的创建、删除、切换","date":"2019-07-01T02:06:00.000Z","updated":"2022-06-04T12:19:27.838Z","comments":true,"path":"2019/07/01/Git分支的创建、删除、切换/","link":"","permalink":"https://www.yangweixing.top/2019/07/01/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E5%88%87%E6%8D%A2/","excerpt":"1、本地创建新分支并切换到新分支 1# git checkout -b 分支名","text":"1、本地创建新分支并切换到新分支 1# git checkout -b 分支名 2、提交分支到远程仓库 1# git push origin 分支名 3、切换分支 1# git checkout 分支名 4、删除远程分支 1# git push origin --delete 分支名 5、删除本地分支 1# git branch -D 分支名 Tips：其他分支命令 查看当前分支 git branch 查看所属分支 git branch -a","categories":[],"tags":[{"name":"日记本","slug":"日记本","permalink":"https://www.yangweixing.top/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"Git彻底删除历史提交记录的方法","slug":"Git彻底删除历史提交记录的方法","date":"2019-06-05T02:22:00.000Z","updated":"2022-06-04T12:19:27.838Z","comments":true,"path":"2019/06/05/Git彻底删除历史提交记录的方法/","link":"","permalink":"https://www.yangweixing.top/2019/06/05/Git%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"1、查看Git提交记录 1# git log 2、找到需要回滚到的提交点，复制它的hash值 1# git reset --hard 你复制的hash值","text":"1、查看Git提交记录 1# git log 2、找到需要回滚到的提交点，复制它的hash值 1# git reset --hard 你复制的hash值 3、将当前指向的head推到git 1# git push --force","categories":[],"tags":[{"name":"日记本","slug":"日记本","permalink":"https://www.yangweixing.top/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"玩转MySQL优化命令","slug":"玩转MySQL优化命令","date":"2019-05-06T10:05:00.000Z","updated":"2022-06-04T12:19:27.841Z","comments":true,"path":"2019/05/06/玩转MySQL优化命令/","link":"","permalink":"https://www.yangweixing.top/2019/05/06/%E7%8E%A9%E8%BD%ACMySQL%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/","excerpt":"1、MySQL更改为只能本地登录 123# use mysql;# select user,host,Password from user where user=&#x27;root&#x27;;# delete from user where user=&#x27;root&#x27; and host=&#x27;%&#x27;;","text":"1、MySQL更改为只能本地登录 123# use mysql;# select user,host,Password from user where user=&#x27;root&#x27;;# delete from user where user=&#x27;root&#x27; and host=&#x27;%&#x27;; 2、MySQL授予外网登陆权限 grant all privileges on *.* to 授予外网登陆的用户名@'%' identified by '密码' WITH GRANT OPTION; 12# grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;root&#x27; WITH GRANT OPTION;# flush privileges; 3、更改MySQL的存储目录","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.yangweixing.top/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.yangweixing.top/tags/MySQL/"}]},{"title":"IDEA设置后端代码开发规范","slug":"IDEA设置后端代码开发规范","date":"2019-01-23T02:33:00.000Z","updated":"2022-06-04T12:19:27.838Z","comments":true,"path":"2019/01/23/IDEA设置后端代码开发规范/","link":"","permalink":"https://www.yangweixing.top/2019/01/23/IDEA%E8%AE%BE%E7%BD%AE%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","excerpt":"1、IDEA 配置svn 提交svn报错：","text":"1、IDEA 配置svn 提交svn报错： 1.1、下载： https://www.visualsvn.com/downloads/ 1.2、修改IDEA配置指向的路径 2、IDEA 设置 Tab 键为 4 个空格 Scheme 选择 Project ,在下面把取消勾选 Use tab character 3、IDEA 设置编码格式为 UTF-8 4、IDEA 设置换行符为 Unix 编码格式 5、IDEA 设置类注释模板 1234/** * * @author Created by 思伟 on $&#123;DATE&#125; */","categories":[],"tags":[{"name":"日记本","slug":"日记本","permalink":"https://www.yangweixing.top/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"Docker 简介","slug":"Docker 简介","date":"2019-01-20T11:36:00.000Z","updated":"2022-06-04T13:02:40.186Z","comments":true,"path":"2019/01/20/Docker 简介/","link":"","permalink":"https://www.yangweixing.top/2019/01/20/Docker%20%E7%AE%80%E4%BB%8B/","excerpt":"Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 [2013 年 3 月以 Apache 2.0 授权协议开源][docker-soft]，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。","text":"Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 [2013 年 3 月以 Apache 2.0 授权协议开源][docker-soft]，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为 容器 。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 官网地址：https://www.docker.com/ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 为什么需要 Docker 概述 作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源 由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间 传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境 开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。 持续交付和部署 对开发和运维（==DevOps==）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 ==Dockerfile== 来进行镜像构建，并结合 ==持续集成(Continuous Integration)== 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 而且使用 ==Dockerfile== 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移 由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展 Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 对比传统虚拟机总结 Docker 引擎 Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。 一种服务器，它是一种称为守护进程并且长时间运行的程序。 REST API 用于指定程序可以用来与守护进程通信的接口，并指示它做什么。 一个有命令行界面 (CLI) 工具的客户端。 Docker 架构 Docker 使用客户端 - 服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。 Docker 容器通过 Docker 镜像来创建。 容器与镜像的关系类似于面向对象编程中的对象与类。 Docker API (https://docs.docker.com/reference/api/docker_remote_api) Docker Hub(https://hub.docker.com) ChangeLog 2019.01.20 19:36 初稿 2019.11.22 14:30 更新","categories":[],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://www.yangweixing.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"Mybatis Generator 代码自动生成工具最全解析","slug":"Mybatis Generator 代码自动生成工具最全解析","date":"2019-01-02T03:36:00.000Z","updated":"2022-06-04T12:19:27.839Z","comments":true,"path":"2019/01/02/Mybatis Generator 代码自动生成工具最全解析/","link":"","permalink":"https://www.yangweixing.top/2019/01/02/Mybatis%20Generator%20%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/","excerpt":"概述 我们无需手动编写 实体类、DAO、XML 配置文件，只需要使用 MyBatis 提供的一个 Maven 插件就可以自动生成所需的各种文件便能够满足基本的业务需求，如果业务比较复杂只需要修改相关文件即可。","text":"概述 我们无需手动编写 实体类、DAO、XML 配置文件，只需要使用 MyBatis 提供的一个 Maven 插件就可以自动生成所需的各种文件便能够满足基本的业务需求，如果业务比较复杂只需要修改相关文件即可。 配置插件 在 pom.xml 文件中增加 mybatis-generator-maven-plugin 插件 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;4.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 注意： configurationFile 自动生成所需的配置文件路径 自动生成的配置 在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- 引入数据库连接配置 --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;!-- 配置 tk.mybatis 插件 --&gt; &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt; &lt;property name=&quot;mappers&quot; value=&quot;xyz.yangweixing.MyMapper&quot;/&gt; &lt;/plugin&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass=&quot;$&#123;jdbc.driverClass&#125;&quot; connectionURL=&quot;$&#123;jdbc.connectionURL&#125;&quot; userId=&quot;$&#123;jdbc.username&#125;&quot; password=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 配置实体类存放路径 --&gt; &lt;javaModelGenerator targetPackage=&quot;xyz.yangweixing.domain&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;!-- 配置 XML 存放路径 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;/&gt; &lt;!-- 配置 DAO 存放路径 --&gt; &lt;javaClientGenerator targetPackage=&quot;xyz.yangweixing.mapper&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt; &lt;!-- 配置需要指定生成的数据库和表，% 代表所有表 --&gt; &lt;table catalog=&quot;myshop&quot; tableName=&quot;%&quot;&gt; &lt;!-- 默认为 false，如果设置为 true，在生成的 SQL 中，table 名字不会加上 catalog 或 schema --&gt; &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;true&quot;/&gt; &lt;!-- mysql 配置 --&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 配置数据源 在 src/main/resources 目录下创建 jdbc.properties 数据源配置： 1234jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.connectionURL=jdbc:mysql://192.168.141.130:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsejdbc.username=rootjdbc.password=123456 附：扩展阅读 完整配置案例说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt;&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项 resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties. 注意，两个属性只能选址一个; 另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用&lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt; --&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包 location属性指明加载jar/zip包的全路径&lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt; --&gt;&lt;!-- context:生成一组对象的环境 id:必选，上下文id，用于在生成错误时提示 defaultModelType:指定生成对象的样式 1，conditional：类似hierarchical； 2，flat：所有内容（主键，blob）等全部生成在一个对象中； 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class) targetRuntime: 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample； 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample； introspectedColumnImpl：类全限定名，用于扩展MBG--&gt;&lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt; &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt; &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt; &lt;!-- 格式化XML代码 --&gt; &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;!-- 必须要有的，使用这个配置链接数据库 @TODO:是否可以扩展 # MySQL 8.x: com.mysql.cj.jdbc.Driver --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt; &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt; &lt;/jdbcConnection&gt; &lt;!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --&gt; &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length&lt;5：使用Short； --&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --&gt; &lt;javaModelGenerator targetPackage=&quot;xyz.yangweixing.domain&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- for MyBatis3/MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --&gt; &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;!-- for MyBatis3 / MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --&gt; &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt; &lt;!-- 设置一个根对象， 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括： 1，属性名相同，类型相同，有相同的getter/setter方法； --&gt; &lt;property name=&quot;rootClass&quot; value=&quot;xyz.yangweixing.domain.BaseDomain&quot;/&gt; &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage/targetProject:同javaModelGenerator --&gt; &lt;sqlMapGenerator targetPackage=&quot;xyz.yangweixing.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage/targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --&gt; &lt;javaClientGenerator targetPackage=&quot;xyz.yangweixing.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt; --&gt; &lt;/javaClientGenerator&gt; &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素 选择的table会生成一下文件： 1，SQL map文件 2，生成一个主键类； 3，除了BLOB和主键的其他字段的类； 4，包含BLOB的类； 5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选； 6，Mapper接口（可选） tableName（必要）：要生成对象的表名； 注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会 根据设置的schema，catalog或tablename去查询数据表，按照下面的流程： 1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询； 2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找； 3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找； 4，否则，使用指定的大小写格式查询； 另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名； 这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式； 可选： 1，schema：数据库的schema； 2，catalog：数据库的catalog； 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面； 5，enableInsert（默认true）：指定是否生成insert语句； 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）； 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句； 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)； 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）； 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句； 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）； 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）； 13，modelType：参考context元素的defaultModelType，相当于覆盖； 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性） 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性 注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写； --&gt; &lt;table tableName=&quot;userinfo&quot; &gt; &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt; &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt; &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt; &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt; &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt; &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt; &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt; &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt; &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt; --&gt; &lt;!-- 参考javaClientGenerator 的 rootInterface 属性 &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt; --&gt; &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt; --&gt; &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt; --&gt; &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt; --&gt; &lt;!-- 注意，该属性只针对MyBatis3Simple有用； 如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件； --&gt; &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt; &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选 column:主键的列名； sqlStatement：要生成的selectKey语句，有以下可选项： Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() Informix :相当于selectKey的SQL为：select dbinfo(&#x27;sqlca.sqlerrd1&#x27;) from systables where tabid=1 MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY JDBC :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性 &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt; --&gt; &lt;!-- 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候， 比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等； 那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是 custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email； 注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的， 如果使用了columnOverride元素，该属性无效； &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt; --&gt; &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性； column:要重新设置的列名； 注意，一个table元素中可以有多个columnOverride元素哈~ --&gt; &lt;columnOverride column=&quot;username&quot;&gt; &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt; &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt; &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名 &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt; --&gt; &lt;!-- jdbcType用于指定该列的JDBC类型 &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt; --&gt; &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=xyz.yangweixing.MyTypeHandler&#125;的参数描述 &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt; --&gt; &lt;!-- 参考table元素的delimitAllColumns配置，默认为false &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt; --&gt; &lt;/columnOverride&gt; &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 column:指定要忽略的列的名字； delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false 注意，一个table元素中可以有多个ignoreColumn元素 &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt; --&gt; &lt;/table&gt;&lt;/context&gt;&lt;/generatorConfiguration&gt; ChangeLog 2019.01.02 11:36 初稿 2019.07.12 20:30 更新 2019.12.15 15:00 更新","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://www.yangweixing.top/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux配置SSH Key到GitHub","slug":"Linux配置SSH-Key到GitHub","date":"2018-12-01T06:48:40.000Z","updated":"2022-06-04T12:19:27.839Z","comments":true,"path":"2018/12/01/Linux配置SSH-Key到GitHub/","link":"","permalink":"https://www.yangweixing.top/2018/12/01/Linux%E9%85%8D%E7%BD%AESSH-Key%E5%88%B0GitHub/","excerpt":"1、生成SSH Key 首先检查下本机是否已经安装了SSH，在终端输入ssh即可： 如果没有安装进行yum安装","text":"1、生成SSH Key 首先检查下本机是否已经安装了SSH，在终端输入ssh即可： 如果没有安装进行yum安装 1# yum -y install openssh-clients 接下来就是生成ssh key了，输入ssh-keygen -t rsa，然后连续按回车键三次（注意：千万不要输入密码！）。 id_rsa.pub为公钥，id_rsa为私钥，它们都是隐藏文件。 那么如何查看它们的内容呢？只需要继续执行以下两条命令即可。 12# cd .ssh/# cat id_rsa.pub 2、添加SSH Key到GitHub上 接着执行下面操作： 点击New SSH Key按钮后进行Key的填写操作，完成SSH Key的添加。如下图： 添加SSH Key成功之后，继续输入命令进行测试。 1# ssh -T git@github.com 出现上图结果则说明添加SSH Key成功。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.yangweixing.top/tags/Linux/"}]},{"title":"SpringBoot 2.0 更新记录","slug":"SpringBoot 2.0 更新记录","date":"2018-08-21T02:43:00.000Z","updated":"2022-06-04T12:19:27.839Z","comments":true,"path":"2018/08/21/SpringBoot 2.0 更新记录/","link":"","permalink":"https://www.yangweixing.top/2018/08/21/SpringBoot%202.0%20%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1、Spring Boot 2.0 要求Java 版本必须8以上 2、配置属性的重定位 Old property New property server.context-path server.servlet.context-path server.context-parameters.* server.servlet.context-parameters.* server.jsp.class-name server.servlet.jsp.class-name server.jsp.init-parameters.* server.servlet.jsp.init-parameters.* server.jsp.registered server.servlet.jsp.registered server.servlet-path server.servlet.path","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.yangweixing.top/tags/Java/"}]},{"title":"Linux下更改MySQL的存储目录","slug":"Linux下更改MySQL的存储目录","date":"2018-08-06T09:06:00.000Z","updated":"2022-06-04T12:19:27.838Z","comments":true,"path":"2018/08/06/Linux下更改MySQL的存储目录/","link":"","permalink":"https://www.yangweixing.top/2018/08/06/Linux%E4%B8%8B%E6%9B%B4%E6%94%B9MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/","excerpt":"重要步骤：一定要先停止Mysql 1# service mysqld stop 1、创建目标文件夹 12# mkdir -p /data/mysql# chown -R mysql.mysql /data/mysql/ 2、迁移命令 1# mysql_install_db --user=mysql --basedir=/usr --datadir=/data/mysql","text":"重要步骤：一定要先停止Mysql 1# service mysqld stop 1、创建目标文件夹 12# mkdir -p /data/mysql# chown -R mysql.mysql /data/mysql/ 2、迁移命令 1# mysql_install_db --user=mysql --basedir=/usr --datadir=/data/mysql 3、为避免麻烦，删掉原文件夹/var/lib/mysql 1# rm -rf /var/lib/mysql/* 4、修改/etc/my.cnf配置文件 12[mysqld]datadir=/data/mysql 5、启动mysql 12# chkconfig mysqld on# service mysqld restart","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.yangweixing.top/tags/Linux/"}]},{"title":"SpringBoot设置默认首页","slug":"SpringBoot设置默认首页","date":"2018-04-26T07:49:00.000Z","updated":"2022-06-04T12:19:27.840Z","comments":true,"path":"2018/04/26/SpringBoot设置默认首页/","link":"","permalink":"https://www.yangweixing.top/2018/04/26/SpringBoot%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E9%A6%96%E9%A1%B5/","excerpt":"","text":"1234567891011@Configurationpublic class DefaultView extends WebMvcConfigurerAdapter&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; super.addViewControllers(registry); //主页 registry.addViewController(&quot;/&quot;).setViewName(&quot;forward:/index&quot;); &#125; &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.yangweixing.top/tags/Java/"}]},{"title":"关于npm install失败的解决方法","slug":"关于npm install失败的解决方法","date":"2018-04-20T08:30:00.000Z","updated":"2022-06-04T12:19:27.840Z","comments":true,"path":"2018/04/20/关于npm install失败的解决方法/","link":"","permalink":"https://www.yangweixing.top/2018/04/20/%E5%85%B3%E4%BA%8Enpm%20install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"可以尝试以下解决方案 1.授权执行 1sudo npm install","text":"可以尝试以下解决方案 1.授权执行 1sudo npm install 2.运行高权限用户 1sudo npm install --unsafe-perm 3.安装某个模块 1sudo npm i 模块名 --unsafe-perms 4.清除代理 1npm config set proxy false 5.清除缓存 1npm cache clean","categories":[],"tags":[{"name":"日记本","slug":"日记本","permalink":"https://www.yangweixing.top/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"vi/vim 粘贴内容时,保留原文件内容格式","slug":"vi或vim粘贴内容时,保留原文件内容格式","date":"2018-04-20T07:50:00.000Z","updated":"2022-06-04T12:19:27.840Z","comments":true,"path":"2018/04/20/vi或vim粘贴内容时,保留原文件内容格式/","link":"","permalink":"https://www.yangweixing.top/2018/04/20/vi%E6%88%96vim%E7%B2%98%E8%B4%B4%E5%86%85%E5%AE%B9%E6%97%B6,%E4%BF%9D%E7%95%99%E5%8E%9F%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"在vi/vim普通模式下执行:set paste命令，再按 i 插入就会保留原文件格式 :set paste 打开粘贴命令 :set nopaste 关闭命令 :h paste 帮助","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.yangweixing.top/tags/Linux/"}]},{"title":"Linux或Win下安装node和npm","slug":"Linux或Win下安装node和npm","date":"2018-04-20T07:31:00.000Z","updated":"2022-06-04T12:19:27.839Z","comments":true,"path":"2018/04/20/Linux或Win下安装node和npm/","link":"","permalink":"https://www.yangweixing.top/2018/04/20/Linux%E6%88%96Win%E4%B8%8B%E5%AE%89%E8%A3%85node%E5%92%8Cnpm/","excerpt":"一、离线安装Node 官网下载链接：https://nodejs.org/zh-cn/download/ node和npm对应关系：https://nodejs.org/zh-cn/download/releases/","text":"一、离线安装Node 官网下载链接：https://nodejs.org/zh-cn/download/ node和npm对应关系：https://nodejs.org/zh-cn/download/releases/ 解压目录 1234# cd /usr/local# yum install -y xz# xz -d node-v8.11.1-linux-x64.tar.xz# tar -xf node-v8.11.1-linux-x64.tar 这里想要全局使用npm 和 node,就需要做相关软链，如下！ 123# cd /usr/local/bin# ln -s /usr/local/src/node-v8.10.0-linux-x64/bin/npm# ln -s /usr/local/src/node-v8.10.0-linux-x64/bin/node 然后即可在任意位置执行 node -v npm -v 查看相应的版本，则安装完成！ 二、yum安装node和npm(Linux快速安装) 12# yum install epel-release -y# yum install nodejs -y 三、使用淘宝镜像站(建议跳过此步骤，不建议使用) 1234# npm config get registry // https://registry.npmjs.org/# npm config set registry https://registry.npm.taobao.org---- 验证是否配置成功# npm config get registry 四、指定全局安装路径和缓存路径(看自己选择是否使用) 设置全局模块的安装路径到 node_global 文件夹， 设置缓存到 node_cache 文件夹 12345# npm config set prefix D:\\nodejs\\node_global# npm config set cache D:\\nodejs\\node_cache---- 验证是否配置成功# npm config get cache# npm ls -g 五、安装 cnpm(看自己选择是否使用) 12# npm install cnpm -g --registry=https://registry.npm.taobao.org# cnpm -v Tips: npm默认的全局目录可执行命令查看 1# npm config ls","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.yangweixing.top/tags/Linux/"}]},{"title":"Linux下安装Git","slug":"Linux下安装Git","date":"2018-04-17T05:41:00.000Z","updated":"2022-06-04T12:19:27.838Z","comments":true,"path":"2018/04/17/Linux下安装Git/","link":"","permalink":"https://www.yangweixing.top/2018/04/17/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Git/","excerpt":"1、使用yum安装 12# yum -y install git# yum remove git 2、源代码安装","text":"1、使用yum安装 12# yum -y install git# yum remove git 2、源代码安装 1234567891011121314151617---安装依赖的包# yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker zlib# cd /usr/local----下载git源码# wget https://github.com/git/git/archive/v2.21.0.tar.gz----解压git源码# tar -zxvf v2.21.0.tar.gz# cd git-2.21.0/# mkdir /usr/local/git----编译安装到指定目录# make prefix=/usr/local/git all# sudo make prefix=/usr/local/git install# vim /etc/profile----添加在文件的最后一行export PATH=/usr/local/git/bin:$PATH# source /etc/profile# git --version 3、FAQ 1、 如果解压时出现报错，建议手动下载git源码包然后上传到服务器 1234gzip: stdin: unexpected end of filetar: Unexpected EOF in archivetar: Unexpected EOF in archivetar: Error is not recoverable: exiting now","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.yangweixing.top/tags/Linux/"}]},{"title":"Hexo博客主题pure使用说明","slug":"Hexo博客主题pure使用说明","date":"2018-04-01T11:54:37.000Z","updated":"2022-06-04T12:01:06.248Z","comments":true,"path":"2018/04/01/Hexo博客主题pure使用说明/","link":"","permalink":"https://www.yangweixing.top/2018/04/01/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98pure%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"Hexo博客主题pure使用说明","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.yangweixing.top/tags/Hexo/"}]},{"title":"Hexo搭建个人博客并部署到Github","slug":"Hexo搭建个人博客并部署到Github","date":"2018-04-01T11:38:34.000Z","updated":"2022-06-04T11:51:59.131Z","comments":true,"path":"2018/04/01/Hexo搭建个人博客并部署到Github/","link":"","permalink":"https://www.yangweixing.top/2018/04/01/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0Github/","excerpt":"","text":"准备 你需要准备好以下软件： Node.js环境和Git Hexo安装 1npm install hexo -g 升级 更新hexo到最新版 1npm update hexo -g 初始化 1hexo init &lt;folder&gt; 如果指定，便会在目前的资料夹建立一个名为的新文件夹；否则会在目前资料夹初始化。 生成网站 1hexo g 启动本地服务 1hexo s 启动服务后，就可以访问：http://localhost:4000/（port 预设为 4000，可在 _config.yml 设定） RSS订阅 命令行切换到hexo博客根目录，安装hexo-generator-feed 1npm install hexo-generator-feed --save 在博客目录的_config.yml中添加如下代码 1234567## feed feed: type: atom path: atom.xml limit: 20 hub: content: sitemap站点地图 命令行切换到hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的sitemap插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在博客目录的_config.yml中添加如下代码 12345## sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 部署步骤 每次部署的步骤，可按以下三步来进行。 123hexo cleanhexo generatehexo deploy 一些常用命令： 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.yangweixing.top/tags/Hexo/"}]}],"categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.yangweixing.top/categories/MySQL/"}],"tags":[{"name":"JAVA 脚手架","slug":"JAVA-脚手架","permalink":"https://www.yangweixing.top/tags/JAVA-%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"name":"设计模式 单例模式 JAVA","slug":"设计模式-单例模式-JAVA","permalink":"https://www.yangweixing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-JAVA/"},{"name":"微服务","slug":"微服务","permalink":"https://www.yangweixing.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"日记本","slug":"日记本","permalink":"https://www.yangweixing.top/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.yangweixing.top/tags/MySQL/"},{"name":"工具","slug":"工具","permalink":"https://www.yangweixing.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Linux","slug":"Linux","permalink":"https://www.yangweixing.top/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"https://www.yangweixing.top/tags/Java/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.yangweixing.top/tags/Hexo/"}]}